<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>John and Friends - Summer Awakening</title>
    <link href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap" rel="stylesheet">
    <style>
        :root { 
            --summer-deep: #1b4332;
            --summer-bright: #74c69d;
            --accent-yellow: #ffef00;
            --font-cute: 'Varela Round', sans-serif;
        }
        body { 
            background: linear-gradient(180deg, #2d6a4f 0%, #95d5b2 100%);
            background-attachment: fixed;
            display: flex; flex-direction: column; align-items: center; 
            font-family: var(--font-cute); margin: 0; 
            touch-action: none; overflow: hidden; height: 100vh;
            position: relative;
        }
        /* Summer Forest Silhouette */
        body::before {
            content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 35%;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="none"><path fill="%231b4332" d="M0,100 L10,70 L20,100 L30,60 L40,100 L55,75 L70,100 L85,65 L100,100 Z"/></svg>');
            background-size: 100% 100%; z-index: -1; opacity: 0.5;
        }

        h1 { color: white; margin: 15px 0 10px 0; font-size: 28px; text-shadow: 0 2px 10px rgba(0,0,0,0.2); }

        /* Music Control Button */
        #music-ctrl {
            position: absolute; top: 15px; right: 15px;
            background: rgba(255,255,255,0.25); border: 2px solid white;
            color: white; border-radius: 50%; width: 44px; height: 44px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 20px; backdrop-filter: blur(10px); z-index: 100;
        }

        /* Bottom UI System - Optimized for Mobile */
        #bottom-ui {
            width: 80%;
            max-width: 330px;
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            z-index: 20;
        }
        #progress-container {
            width: 100%; height: 12px; background: rgba(255,255,255,0.3);
            border-radius: 10px; overflow: hidden; border: 2px solid white;
            position: relative;
        }
        #progress-bar { 
            height: 100%; width: 0%; background: var(--accent-yellow); 
            transition: width 0.4s ease-out; 
        }
        .bottom-text {
            color: white; font-size: 11px; letter-spacing: 1px;
            text-transform: uppercase; opacity: 0.9; font-weight: bold;
        }

        #game-box { padding: 10px; background: #e9c46a; border: 6px solid #cc8e35; border-radius: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); z-index: 10; }
        canvas { border-radius: 18px; background: rgba(255, 255, 255, 0.85); display: block; }
        
        #win-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(27, 67, 50, 0.95); flex-direction: column;
            align-items: center; justify-content: center; z-index: 1000; color: white; text-align: center;
            padding: 20px;
        }
        .win-btn {
            margin-top: 30px; padding: 15px 40px; background: var(--accent-yellow); color: #1b4332;
            border: none; border-radius: 30px; font-size: 20px; cursor: pointer; font-weight: bold;
        }
    </style>
</head>
<body>

    <button id="music-ctrl">ðŸ”‡</button>

    <h1>John and Friends</h1>

    <div id="game-box"><canvas id="gameCanvas"></canvas></div>

    <div id="bottom-ui">
        <span class="bottom-text">Wake up the forest</span>
        <div id="progress-container"><div id="progress-bar"></div></div>
    </div>

    <div id="win-screen">
        <h2 style="font-size: 36px; margin-bottom: 10px;">The Forest is Awake!</h2>
        <p style="font-size: 18px; opacity: 0.9;">Great job! You and your friends saved the summer.</p>
        <button class="win-btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <audio id="bgm"><source src="theme-song.mp3" type="audio/mpeg"></audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bgm = document.getElementById('bgm');
        const musicBtn = document.getElementById('music-ctrl');
        const progressBar = document.getElementById('progress-bar');
        const winScreen = document.getElementById('win-screen');

        const sfxMove = new Audio('move.mp3');
        const sfxMatch = new Audio('match.mp3');
        
        const ROWS = 7, COLS = 7, SIZE = 48; // ç¨å¾®ç¼©å°æ–¹å—ä»¥é€‚é…æ‰‹æœºå±å¹•
        const TARGET_SCORE = 2000; 
        const charNames = ['John', 'Mary Ann', 'Goose', 'Moose', 'Crow'];
        
        let images = {}, board = [], score = 0, isWon = false;
        let dragStart = null, isAnimating = false, isMusicActive = false;
        let floatingTexts = [], fadeTimer = null, nextPlayTimer = null;

        charNames.forEach(name => { images[name] = new Image(); images[name].src = name + '.png'; });

        // --- Music Logic ---
        function fadeMusic(target, duration, callback) {
            clearInterval(fadeTimer);
            const step = 0.05;
            const interval = duration / (target === 0 ? (bgm.volume / step || 1) : (target / step));
            fadeTimer = setInterval(() => {
                if (target > bgm.volume) {
                    bgm.volume = Math.min(bgm.volume + step, target);
                    if (bgm.volume >= target) { clearInterval(fadeTimer); if(callback) callback(); }
                } else {
                    bgm.volume = Math.max(bgm.volume - step, 0);
                    if (bgm.volume <= 0) { clearInterval(fadeTimer); bgm.pause(); if(callback) callback(); }
                }
            }, interval);
        }

        musicBtn.addEventListener('click', () => {
            if (isMusicActive) {
                isMusicActive = false;
                clearTimeout(nextPlayTimer);
                fadeMusic(0, 1500, () => musicBtn.innerText = "ðŸ”‡");
            } else {
                isMusicActive = true;
                musicBtn.innerText = "ðŸ”Š";
                bgm.volume = 0;
                bgm.play().catch(e => console.log("User interaction required"));
                fadeMusic(1.0, 2000);
            }
        });

        bgm.addEventListener('ended', () => {
            if (isMusicActive) {
                nextPlayTimer = setTimeout(() => {
                    if (isMusicActive) {
                        bgm.volume = 0;
                        bgm.play();
                        fadeMusic(1.0, 2000);
                    }
                }, 5000);
            }
        });

        function init() {
            const dpr = window.devicePixelRatio || 2;
            canvas.width = (COLS * SIZE) * dpr; canvas.height = (ROWS * SIZE) * dpr;
            canvas.style.width = (COLS * SIZE) + 'px'; canvas.style.height = (ROWS * SIZE) + 'px';
            ctx.scale(dpr, dpr);

            for (let r = 0; r < ROWS; r++) {
                board[r] = [];
                for (let c = 0; c < COLS; c++) {
                    let type;
                    do { type = Math.floor(Math.random() * 5); }
                    while ((c >= 2 && board[r][c-1].type === type && board[r][c-2].type === type) || (r >= 2 && board[r-1][c].type === type && board[r-2][c].type === type));
                    board[r][c] = { type, animX: 0, animY: 0 };
                }
            }
            requestAnimationFrame(renderLoop);
        }

        function renderLoop() {
            if(isWon) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const tile = board[r][c]; if (!tile) continue;
                    tile.animX *= 0.75; tile.animY *= 0.75;
                    ctx.save();
                    ctx.translate(c*SIZE + tile.animX + SIZE/2, r*SIZE + tile.animY + SIZE/2);
                    const padding = 3, cornerRadius = 12, thickness = 4;
                    const grad = ctx.createLinearGradient(0, -SIZE/2, 0, SIZE/2);
                    grad.addColorStop(0, '#74c69d'); grad.addColorStop(1, '#2d6a4f');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.roundRect(-SIZE/2 + padding, -SIZE/2 + padding + thickness, SIZE - padding*2, SIZE - padding*2, cornerRadius);
                    ctx.fill();
                    ctx.fillStyle = "#ffffff";
                    ctx.beginPath();
                    ctx.roundRect(-SIZE/2 + padding, -SIZE/2 + padding, SIZE - padding*2, SIZE - padding*2, cornerRadius);
                    ctx.fill();
                    const img = images[charNames[tile.type]];
                    if (img?.complete) ctx.drawImage(img, -SIZE/2 + 7, -SIZE/2 + 7, SIZE - 14, SIZE - 14);
                    ctx.restore();
                }
            }

            // æ›´æ–°åº•éƒ¨è¿›åº¦æ¡å®½åº¦
            const progress = Math.min((score / TARGET_SCORE) * 100, 100);
            progressBar.style.width = progress + "%";
            
            if(score >= TARGET_SCORE && !isWon) { 
                isWon = true; 
                setTimeout(() => winScreen.style.display = 'flex', 600); 
            }

            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                let ft = floatingTexts[i]; ctx.fillStyle = `rgba(27, 67, 50, ${ft.alpha})`;
                ctx.font = "bold 16px 'Varela Round'"; ctx.textAlign = "center";
                ctx.fillText(ft.val, ft.x, ft.y); ft.y -= 1; ft.alpha -= 0.02; if(ft.alpha <= 0) floatingTexts.splice(i,1);
            }
            requestAnimationFrame(renderLoop);
        }

        async function processSequence(m) {
            let combo = 0;
            while(m) {
                const s = sfxMatch.cloneNode();
                s.playbackRate = Math.min(1 + (combo * 0.2), 2); s.play();
                let count = 0, fx, fy;
                for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
                    if(m[r][c]) { if(count===0){fx=c*SIZE; fy=r*SIZE;} board[r][c]=null; count++; }
                }
                const gain = count * 10 + (combo * 20);
                score += gain;
                floatingTexts.push({val: combo > 0 ? `COMBO! +${gain}` : `+${gain}`, x: fx+SIZE/2, y: fy+SIZE/2, alpha: 1});
                combo++;
                await new Promise(r => setTimeout(r, 250));
                for(let c=0; c<COLS; c++) {
                    let empty = ROWS-1;
                    for(let r=ROWS-1; r>=0; r--) {
                        if(board[r][c]){
                            let oldR = r; board[empty][c]=board[r][c];
                            if(empty!==r){ board[empty][c].animY=(oldR-empty)*SIZE; board[r][c]=null; }
                            empty--;
                        }
                    }
                    for(let r=empty; r>=0; r--) board[r][c]={type:Math.floor(Math.random()*5), animX:0, animY:-ROWS*SIZE};
                }
                await new Promise(r => setTimeout(r, 350));
                m = getMatches();
            }
        }

        async function slideSwap(r1, c1, r2, c2) {
            if(isWon) return;
            isAnimating = true; sfxMove.play();
            const t1 = board[r1][c1], t2 = board[r2][c2];
            t1.animX = (c2-c1)*SIZE; t1.animY = (r2-r1)*SIZE;
            t2.animX = (c1-c2)*SIZE; t2.animY = (r1-r2)*SIZE;
            [t1.type, t2.type] = [t2.type, t1.type];
            await new Promise(r => setTimeout(r, 200));
            const m = getMatches();
            if(m) await processSequence(m);
            else { [t1.type, t2.type] = [t2.type, t1.type]; t1.animX=t1.animY=t2.animX=t2.animY=0; }
            isAnimating = false;
        }

        function getMatches() {
            let matched = Array.from({length: ROWS}, () => Array(COLS).fill(false));
            let found = false;
            for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
                let t = board[r][c]?.type; if(t===undefined) continue;
                if(c<COLS-2 && board[r][c+1]?.type===t && board[r][c+2]?.type===t) matched[r][c]=matched[r][c+1]=matched[r][c+2]=found=true;
                if(r<ROWS-2 && board[r+1][c]?.type===t && board[r+2][c]?.type===t) matched[r][c]=matched[r+1][c]=matched[r+2][c]=found=true;
            }
            return found ? matched : null;
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { c: Math.floor((cx - rect.left) / (rect.width / COLS)), r: Math.floor((cy - rect.top) / (rect.height / ROWS)) };
        }
        canvas.addEventListener('mousedown', (e) => { if(!isAnimating) dragStart = getPos(e); });
        window.addEventListener('mousemove', (e) => { if(!dragStart || isAnimating) return; const cur = getPos(e); if(Math.abs(cur.c - dragStart.c) + Math.abs(cur.r - dragStart.r) === 1) { slideSwap(dragStart.r, dragStart.c, cur.r, cur.c); dragStart = null; } });
        canvas.addEventListener('touchstart', (e) => { if(!isAnimating) dragStart = getPos(e); });
        window.addEventListener('touchmove', (e) => { if(!dragStart || isAnimating) return; const cur = getPos(e); if(Math.abs(cur.c - dragStart.c) + Math.abs(cur.r - dragStart.r) === 1) { slideSwap(dragStart.r, dragStart.c, cur.r, cur.c); dragStart = null; } });
        window.addEventListener('mouseup', () => dragStart = null);
        window.addEventListener('touchend', () => dragStart = null);

        init();
    </script>
</body>
</html>
